# 12\. Error Handling Strategy

## General Approach

  - **Error Model:** Use a standardized error response format for all REST APIs, including an error code, a user-friendly message, and a technical detail message (for development/logging only).
    ```json
    {
      "code": "ORDER_NOT_FOUND",
      "message": "The requested order could not be found.",
      "details": "Order with ID XXXXX not found in database."
    }
    ```
  - **Exception Hierarchy:** Define a custom exception hierarchy (e.g., `BaseApplicationException`, with subclasses like `ResourceNotFoundException`, `InvalidInputException`, `ServiceUnavailableException`) that extends `RuntimeException` for unchecked exceptions. Convert checked exceptions from external libraries/APIs into appropriate custom runtime exceptions.
  - **Error Propagation:** Exceptions should be caught at the service layer boundaries and translated into appropriate custom exceptions. At the controller/API layer, these custom exceptions are caught by a global exception handler (e.g., Spring's `@ControllerAdvice`) which then maps them to standardized HTTP status codes and the common error response format.

## Logging Standards

  - **Library:** SLF4J with Logback (for Spring Boot).
  - **Format:** JSON format for centralized logging (e.g., using Logstash Encoder). This allows for easy parsing and querying in OpenObserver/ELK.
  - **Levels:**
      - `ERROR`: Critical application errors that require immediate attention (e.g., database connection failures, unhandled exceptions).
      - `WARN`: Potentially problematic situations, non-critical errors, deprecated features.
      - `INFO`: General application flow, significant events (e.g., user login, order placed).
      - `DEBUG`: Detailed information for development and troubleshooting (e.g., detailed request/response, method entry/exit).
      - `TRACE`: Most granular level, for very fine-grained debugging.
  - **Required Context:**
      - **Correlation ID:** `X-Request-ID` HTTP header will be generated by API Gateway or the first service hit and propagated across all internal service calls and logs. This enables tracing a single request across distributed services.
      - **Service Context:** Include service name, host, and pod ID in every log entry.
      - **User Context:** Log `user_id` (if authenticated) with `INFO`/`DEBUG` logs, but **NEVER** log sensitive user data (passwords, PII).

## Error Handling Patterns

### External API Errors

  - **Retry Policy:** Implement retry mechanisms with exponential backoff and jitter for transient external API errors (e.g., network issues, temporary service unavailability). Use libraries like Resilience4j or Spring Retry.
  - **Circuit Breaker:** Apply Circuit Breaker pattern (e.g., using Resilience4j) to prevent a failing external service from cascading failures throughout the system.
  - **Timeout Configuration:** Explicitly configure connection and read timeouts for all external API calls to prevent indefinite waiting and resource exhaustion.
  - **Error Translation:** Translate specific external API error codes or responses into meaningful internal custom exceptions to maintain consistency across the application.

### Business Logic Errors

  - **Custom Exceptions:** Define specific custom exceptions for business rule violations (e.g., `InvalidOrderStateException`, `VendorNotAvailableException`, `InsufficientFundsException`). These should be distinct from technical exceptions.
  - **User-Facing Errors:** Business logic errors should be translated into clear, user-friendly messages for client applications, while retaining technical details in logs for debugging.
  - **Error Codes:** Implement a consistent system of application-specific error codes for both client-facing messages and internal logging, facilitating easier identification and handling.

### Data Consistency

  - **Transaction Strategy:** Use Spring's `@Transactional` annotation for defining explicit transactional boundaries, ensuring atomicity for database operations. For operations spanning multiple services (e.g., order placement leading to payment), rely on Kafka for eventual consistency and compensate for failures.
  - **Compensation Logic:** For multi-step business processes (sagas) involving asynchronous communication via Kafka, implement compensation transactions to revert or undo actions in case of a failure in a later step.
  - **Idempotency:** Implement idempotency keys for critical write operations (e.g., creating orders, processing payments) to ensure that repeated requests due to retries or network issues do not lead to duplicate data or unintended side effects.
